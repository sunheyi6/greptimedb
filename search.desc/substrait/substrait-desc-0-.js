searchState.loadedDescShard("substrait", 0, "Serializer and deserializer registry for extensions like …\nDeserialize user defined logical plan node (…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSerialize this node to a byte array. This serialization …\nRe-export the Substrait module of datafusion, note this is …\nType variation constants\nDefault SubstraitConsumer for converting standard …\nAn ExprContainer is a container for a collection of …\nThis trait is used to consume Substrait plans, converting …\nAll Expressions to be converted pass through this method. …\nAll Rels to be converted pass through this method. You can …\nThe expressions\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert Substrait AggregateFunction to DataFusion Expr\nConvert Substrait ExtendedExpression to ExprContainer\nConvert Substrait FunctionArguments to DataFusion Exprs\nConvert Substrait NamedStruct to DataFusion DFSchemaRef\nConvert Substrait Plan to DataFusion LogicalPlan\nConvert Substrait Plan to DataFusion LogicalPlan using the …\nConvert Substrait Rel to DataFusion DataFrame\nConvert Substrait Rex to DataFusion Expr\nConvert Substrait Expressions to DataFusion Exprs\nConvert Substrait Sorts to DataFusion Exprs\nThe input schema for the expressions\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTraverse through the data type (incl. lists/maps/etc), …\nTraverse through the field, renaming the provided field …\nRename the field’s data type but not the field itself.\nThis trait is used to produce Substrait plans, converting …\nReturns the argument unchanged.\nConsume the producer to generate the Extensions for the …\nFor handling Not, IsNotNull, IsNull, IsTrue, IsFalse, …\nCalls <code>U::from(self)</code>.\nReturn Substrait scalar function with two arguments\nWithin a Substrait plan, functions are referenced using …\nSerializes a collection of expressions to a Substrait …\nConvert DataFusion LogicalPlan to Substrait Plan\nConvert DataFusion Expr to Substrait Rex\nSNAFU context selector for the <code>Error::DecodeDfPlan</code> variant\nSNAFU context selector for the <code>Error::DecodeRel</code> variant\nSNAFU context selector for the <code>Error::EncodeDfPlan</code> variant\nSNAFU context selector for the <code>Error::EncodeRel</code> variant\nContains the error value\nSNAFU context selector for the <code>Error::Internal</code> variant\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nDeserialize user defined logical plan node (…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSerialize this node to a byte array. This serialization …\nUsed for the arrow type <code>DataType::Interval</code> with …\nThe “system-preferred” variation (i.e., no variation).\nUsed for the arrow type <code>DataType::Duration</code>.\nFor <code>DataType::Interval</code> with <code>IntervalUnit::DayTime</code>.\nFor <code>DataType::Interval</code> with <code>IntervalUnit::MonthDayNano</code>.\nFor <code>DataType::Interval</code> with <code>IntervalUnit::MonthDayNano</code>.\nFor <code>DataType::Interval</code> with <code>IntervalUnit::YearMonth</code>.")